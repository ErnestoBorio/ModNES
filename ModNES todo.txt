
Próximos pasos:

> Prioridad sprites - background
> FPS count y modo async a ver cuántos FPS tira ModNES unbound

> Mappers!
    Easiest and most popular first:
    3-CNROM:  78 games: Solomon's Key, Gradius, and Hudson's Adventure Island (CHR switching only - easy)
    11-Color Dreams: 28 games: Crystal Mines, Metal Fighter (easy)
    2-UNROM: 106 games: Castlevania, MegaMan, Ghosts & Goblins. (CHR-RAM)
    7-AOROM:  33 games: Battletoads, Marble Madness, and Solar Jetman. (CHR-RAM)
    4-MMC3:  310 games: Super Mario Bros. 2 and 3, MegaMan 3, 4, 5, and 6, and Crystalis
    1-MMC1:  251 games: Final Fantasy, Mega Man 2, Metroid, Zelda, Zelda 2, Castlevania 2
    
    Estos 5 mappers más NROM suman 891 juegos, todos los demás mappers tienen pocos juegos y poco conocidos, no vale la pena implementarlos.

> Hacer que OAM DMA empiece en OAM ADDR 2003 (sólo si algún juego escribe !=0 en OAM ADDR)
> Visual debugger, si es que hace falta. (Cocoa nativo GUI? implementar alguna SDL GUI? GUI propia?)
> Hacer accurate sprite 0 hit

> Brush roller trata de acceder a $4800 なに!!
> Ice climber también trata de acceder a un read unimplemented. Raro, la versión anterior con Cocoa OpenGL me parece que no fallaba.

> Implementar también OAM READ/WRITE 2004 (si? o dejar un assert y ver si algún juego lo usa)

> Implementar 8 sprites overflow flag (Según http://wiki.nesdev.com/w/index.php/Sprite_overflow_games sólo 7 juegos
   dependen de este flag, es de muy baja prioridad implementarlo.)

> Implementar open bus para lectura de registros y demás.
Los registros de solo escritura devuelven el openbus al ser leidos.
Los registros que solo usan pocos bits, como $2002, el resto de los bits viene del openbus.
(en general los read unimplemented de los registros, seguro devuelven openbus)
El openbus es el último byte leído de la memoria. (consultar documentación a ver si puede haber algo más)

> Input completo con redefine keys

> Eliminar la práctica de include .c dentro de .c (sacar funciones static)
Debería? esto permite hacer funciones "privadas" con static. Pero xcode ignora los breakpoints en estos archivos.
Quizás se pueda hacer que Xcode haga andar igual estos breakpoints.
Ya hice esto con MemoryAccess.c, quedan Instructions.c y Addressing.c

> $2002.4 "VRAM write enable/disable" según una Doc, que las demás contradicen. Averiguar qué onda.
(Por ahora lo ignoro olímpicamente)

--- done
√ scroll a pantalla partida
√ Basic Input
√ Pausa
√ Implementar sprite 0 hit (básico)
√ Scroll pantalla completa
√ SDL 2
√ Implementar read_memory_disasm para no usar los handlers comunes de registros
√ Implementar save RAM (Pero sin persistencia)
√ Implementar cpu y ppu cycle counting, y quizas también frame count a nivel Nes.