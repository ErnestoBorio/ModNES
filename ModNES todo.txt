
Próximos pasos:

>> Mapper CNROM:
Cargar todos los CHR-ROM banks y crear las surfaces accordingly
Switchear CHR-ROM y surfaces

- CNROM
PRG ROM size: 16 KiB or 32 KiB
PRG ROM bank size: Not bankswitched
PRG RAM: None
CHR capacity: Up to 2048 KiB ROM
CHR bank size: 8 KiB

PPU $0000-$1FFF: 8 KB switchable CHR ROM bank

- Registro:
Bank select ($8000-$FFFF)
7  bit  0
---- ----
cccc ccCC
|||| ||||
++++-++++- Select 8 KB CHR ROM bank for PPU $0000-$1FFF

CNROM only implements the lowest 2 bits, capping it at 32 KiB CHR. Other boards may implement 4 or more bits for larger CHR.

Cada banco de CHR-ROM ocupa 8kB, 0-1FFF
Separado en dos pattern tables de 4kB, 0-0FFF y 1000-1FFFF

> CNROM todo:
√ leer mapper en load ROM // this->mapper = header[6] & 0xF0;

√ redefinir containers de CHR-ROM compressed para que sea collection
√ agregar puntero a CHR-ROM bank actual
√ mallocear el contenedor de los CHR-ROM.
√ freear el contenedor de los CHR-ROM.

- Volver a entender cómo funcionan los uncompressed.
- redefinir containers de CHR-ROM uncompressed para que sea collection
- agregar puntero a CHR-ROM uncompressed bank actual
- mallocear el contenedor de los CHR-ROM uncompressed.
- freear el contenedor de los CHR-ROM uncompressed.

- modificar todo el código que accede a CHR-ROM para acceda indexado ahora.
- crear y blittear a las SDL surfaces correspondientes cuando haga falta.
- Uncompressear los multiples CHR-ROM
- hacer los memory handlers para switchear CHR-ROM banks
- trappear si se usan más de dos bits en el switch register (no debería? debería ignorar?)
- Actualizar todas las SDL surfaces que sea necesario al switchear banks







> Mappers!
    Easiest and most popular first:
    3-CNROM:  78 games: Solomon's Key, Gradius, and Hudson's Adventure Island (CHR switching only - easy)
    11-Color Dreams: 28 games: Crystal Mines, Metal Fighter (easy)
    2-UNROM: 106 games: Castlevania, MegaMan, Ghosts & Goblins. (CHR-RAM)
    7-AOROM:  33 games: Battletoads, Marble Madness, and Solar Jetman. (CHR-RAM)
    4-MMC3:  310 games: Super Mario Bros. 2 and 3, MegaMan 3, 4, 5, and 6, and Crystalis
    1-MMC1:  251 games: Final Fantasy, Mega Man 2, Metroid, Zelda, Zelda 2, Castlevania 2
    
    Estos 5 mappers más NROM suman 891 juegos, todos los demás mappers tienen pocos juegos y poco conocidos, no vale la pena implementarlos.
    * Corrección posterior: estos 6 mappers.




> Hacer que OAM DMA empiece en OAM ADDR 2003 (sólo si algún juego escribe !=0 en OAM ADDR)
> Visual debugger, si es que hace falta. (Cocoa nativo GUI? implementar alguna SDL GUI? GUI propia?)
> Hacer accurate sprite 0 hit

> El scroll vertical no está bien en Xevious. En ciertos momentos se desincroniza y la actualización del background se ve en las 3 o 4 filas de abajo, esto no debería superar una fila de tiles.

> Brush roller trata de acceder a $4800 なに!!
> Ice climber también trata de acceder a un read unimplemented. Raro, la versión anterior con Cocoa OpenGL me parece que no fallaba.

> Implementar también OAM READ/WRITE 2004 (si? o dejar un assert y ver si algún juego lo usa)

> Implementar 8 sprites overflow flag (Según http://wiki.nesdev.com/w/index.php/Sprite_overflow_games sólo 7 juegos
   dependen de este flag, es de muy baja prioridad implementarlo.)

> Implementar open bus para lectura de registros y demás.
Los registros de solo escritura devuelven el openbus al ser leidos.
Los registros que solo usan pocos bits, como $2002, el resto de los bits viene del openbus.
(en general los read unimplemented de los registros, seguro devuelven openbus)
El openbus es el último byte leído de la memoria. (consultar documentación a ver si puede haber algo más)

> Input completo con redefine keys

> Eliminar la práctica de include .c dentro de .c (sacar funciones static)
Debería? esto permite hacer funciones "privadas" con static. Pero xcode ignora los breakpoints en estos archivos.
Quizás se pueda hacer que Xcode haga andar igual estos breakpoints.
Ya hice esto con MemoryAccess.c, quedan Instructions.c y Addressing.c

> $2002.4 "VRAM write enable/disable" según una Doc, que las demás contradicen. Averiguar qué onda.
(Por ahora lo ignoro olímpicamente)


--- done

√ FPS count y modo async a ver cuántos FPS tira ModNES unbound (100 fps)
√ No renderear pantalla cuando back y sprites están disabled
√ Left tile column clipping
√ Prioridad sprites - background
√ scroll a pantalla partida
√ Basic Input
√ Pausa
√ Implementar sprite 0 hit (básico)
√ Scroll pantalla completa
√ SDL 2
√ Implementar read_memory_disasm para no usar los handlers comunes de registros
√ Implementar save RAM (Pero sin persistencia)
√ Implementar cpu y ppu cycle counting, y quizas también frame count a nivel Nes.