
Próximos pasos:

> Scroll mid-frame y scroll viewport partido
http://wiki.nesdev.com/w/index.php/PPU_scrolling
http://wiki.nesdev.com/w/index.php/PPU_registers#Scroll_.28.242005.29_.3E.3E_write_x2
    "Changes made to the vertical scroll during rendering will only take effect on the next frame"
    "Normal" vertical offsets range from 0 to 239, while values of 240 to 255 are treated as -16 through -1 in a way, but tile data is incorrectly fetched from the attribute table.

- Falta hacer wrap around en X e Y del viewport y del bliteo a screen.
- Registrar cuándo cambia x scroll en midframe, y en ese scanline splitear el viewport
- assert de scroll Y >= 240
- assert de modificación de scroll Y midframe

> Input
> Pausa
> FPS count y modo async a ver cuántos FPS tira ModNES unbound

> Mappers!

> Hacer que OAM DMA empiece en OAM ADDR 2003 (sólo si algún juego escribe !=0 en OAM ADDR)
> Visual debugger. (Cocoa nativo GUI? implementar alguna SDL GUI? GUI propia?)
> Hacer accurate sprite 0 hit

> Brush roller trata de acceder a $4800 なに!!
> Ice climber también trata de acceder a un read unimplemented. Raro, la versión anterior con Cocoa OpenGL me parece que no fallaba.

> Implementar también OAM READ/WRITE 2004 (si? o dejar un assert y ver si algún juego lo usa)

> Implementar 8 sprites overflow flag (Según http://wiki.nesdev.com/w/index.php/Sprite_overflow_games sólo 7 juegos
   dependen de este flag, es de muy baja prioridad implementarlo.)

> Implementar open bus para lectura de registros y demás.
Los registros de solo escritura devuelven el openbus al ser leidos.
Los registros que solo usan pocos bits, como $2002, el resto de los bits viene del openbus.
(en general los read unimplemented de los registros, seguro devuelven openbus)
El openbus es el último byte leído de la memoria. (consultar documentación a ver si puede haber algo más)

> Eliminar la práctica de include .c dentro de .c (sacar funciones static)
Debería? esto permite hacer funciones "privadas" con static. Pero xcode ignora los breakpoints en estos archivos.
Quizás se pueda hacer que Xcode haga andar igual estos breakpoints.
Ya hice esto con MemoryAccess.c, quedan Instructions.c y Addressing.c

> $2002.4 "VRAM write enable/disable" según una Doc, que las demás contradicen. Averiguar qué onda.
(Por ahora lo ignoro olímpicamente)

--- done
√ Implementar sprite 0 hit (básico)
√ Scroll pantalla completa
√ SDL 2
√ Implementar read_memory_disasm para no usar los handlers comunes de registros
√ Implementar save RAM
√ Implementar cpu y ppu cycle counting, y quizas también frame count a nivel Nes.