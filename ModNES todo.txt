
Próximos pasos:

> SDL!
Holamundeando SDL2.
ALTA biblioteca, wachin.
Descubrí que usando surfaces 8 bpp, si altero los colores de la patleta (no la paleta en sí), antes de blitear, se blitea
correctamente con la paleta deseada.

Voy a implementar cada pattern table como una surface de 256 tiles, o sea 16x16 tiles, 128x128 px
Luego por cada tile que tengo que blitear como fondo o como sprite, ahí le seteo los colores de la paleta y depsués bliteo.
Puedo cachear los tiles vacíos y no blitearlos.
Bliteo en 4 planos: fondo todo del color de fondo, luego sprites por abajo del fondo, luego fondo, luego sprites por arriba de fondo.
Sprites se renderean en orden inverso a sprite number.
(por ahora me cago en sprites bajofondo que tienen mayor prioridad que sprites sobrefondo.)

> Pausa

> Scroll

> Mappers

> FPS count

> Brush roller trata de acceder a $4800 なに!!

---

> Implementar sprite 0 hit ( √ implementado muy básicamente )

> Hacer que OAM DMA empiece en OAM ADDR 2003 (sólo si algún juego escribe !=0 en OAM ADDR)

> Implementar también OAM READ/WRITE 2004 (si? o dejar un assert y ver si algún juego lo usa)

> Implementar 8 sprites overflow flag (Según http://wiki.nesdev.com/w/index.php/Sprite_overflow_games sólo 7 juegos
   dependen de este flag, es de muy baja prioridad implementarlo.)

> Un nice to have pero no escencial sería renderear cada tile de los pattern tables con la última paleta con el que fue
rendereado en la pantalla. Igual esto es prioridad 0, porque sirve sólo para que se va lindo el visual debugger, no tiene
incidencia en el ModNES final.

> Implementar open bus para lectura de registros y demás.
Los registros de solo escritura devuelven el openbus al ser leidos.
Los registros que solo usan pocos bits, como $2002, el resto de los bits viene del openbus.
(en general los read unimplemented de los registros, seguro devuelven openbus)

> Eliminar la práctica de include .c dentro de .c (sacar funciones static)
Debería? esto permite hacer funciones "privadas" con static. Pero xcode ignora los breakpoints en estos archivos.
Quizás se pueda hacer que Xcode haga andar igual estos breakpoints.
Ya hice esto con MemoryAccess.c, quedan Instructions.c y Addressing.c

> $2002.4 "VRAM write enable/disable" según una Doc, que las demás contradicen. Averiguar qué onda.
(Por ahora lo ignoro olímpicamente)


--- done
√ Implementar read_memory_disasm para no usar los handlers comunes de registros
√ Implementar save RAM
√ Implementar cpu y ppu cycle counting, y quizas también frame count a nivel Nes.