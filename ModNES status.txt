
>> 2016-03-10

Reimplementé el render en SDL, con pallette swaps bliteando de a tiles en vez de a pixel.
Ahora hay ventanas de: Patterns, Nametables y Screen.
Sprites y Pallettes no las hice en SDL, y no las voy a hacer hasta que no las necesite.
Por fin implementé el scroll en 2D, aunque solo en pantalla completa, no split-screen todavía.
Por primera vez ModNES renderea al screen con scroll y le da un aspecto vivo, cada vez más se parece a una NES verdadera.
Al querer hacer el flipping de sprites me di cuenta de que SDL no tiene BlitFlipped() me sorprendió.
Sí tiene para renderers y texturas, seguramente eso lo hace el framework subyacente, e.g. OpenGL.
Tendría que branchear y probar con renderers y texturas a ver si puedo hacer lo mismo que con surfaces. Probablemente no pueda hacer color keying y pallette swap.
El aprendizaje de git con Germinate me sirvió para manejar este proyecto mejor, los conceptos de branching y merging son muy simples pero muy poderosos.


>> 2015-XX-XX En algún punto entre la fecha anterior y la siguiente (lo había puesto en to do)

Holamundeando SDL2.
Descubrí que usando surfaces 8 bpp, si altero los colores de la patleta (no la paleta en sí), antes de blitear, se blitea
correctamente con la paleta deseada.

Voy a implementar cada pattern table como una surface de 256 tiles, o sea 16x16 tiles, 128x128 px
Luego por cada tile que tengo que blitear como fondo o como sprite, ahí le seteo los colores de la paleta y depsués bliteo.
Puedo cachear los tiles vacíos y no blitearlos.
Bliteo en 4 planos: fondo todo del color de fondo, luego sprites por abajo del fondo, luego fondo, luego sprites por arriba de fondo.
Sprites se renderean en orden inverso a sprite number.
(por ahora me cago en sprites bajofondo que tienen mayor prioridad que sprites sobrefondo.)


>> 2015-08-30

Bueno el evento más importante de ModNES fue tan impactante que no escribí nada acá.
Finalmente el emu dibuja fondos y sprites, y agregué input de modo que se pueden jugar algunos juegos.
Acá está la entrada en git del 19/6:

Added Sprites and Screen views.
Added input handling for gamepad #0.
It's Alive!!! this commit is the first minimum viable emulator of ModNES that ever worked, it has minimal screen output and gamepad input so you can actually play some games.

Ahora unifiqué los tres repositorios Cpu6502, Nes y ModNES en uno solo: ModNES.
También dejé Cocoa y me pasé a SDL2, que permite manejar varias ventanas, y además testeando descubrí que con superficies de 8 bpp puedo cambiarles los colores de la paleta efectivamente haciendo palette swaps igual que la NES, o sea que puedo guardar los nametables como surfaces y blitearlas en la pantalla con palette swaps sin necesidad de recalcular los colores pixel por pixel.

>> 2015-05-10 Miércoles (lol, sería 2015-05-13? )

Bueno finalmente arreglé unos addressings erróneos, y le agregué addressing mode a los NOP ilegales, para poder skipearlos y seguir ejecutando.
Ahora Cpu6502 pasa exitosamente Nestest! FUCK YEAH!
Con la excepción de los opcodes ilegales más allá del NOP.
Para los NOP ilegales hay una excepción, al no ejecutar el addressing, los NOP Absolute,X si el direccionamiento cruza un límite de página, 
obviamente no estoy agregando el ciclo extra, por lo tanto si se trata de ejecutar un NOP ilegal y se da esta puta casualidad, el conteo de 
ciclos de CPU va a estar uno abajo de lo correcto, me cago, no creo que sea demasiado serio.
Esto se podría arreglar ejecutando el addresing para estos NOPs pero creo que no vale la pena ni agacharse por tan poco.

Mejoras a futuro:
Llamar primero al addressing y después a la instrucción, ambos según las correspondientes tablas, en vez de hacer el switch
largo y verbose de CpuStep. (Como hacía antes, con los dos switch y el poderoso goto)
El PC se puede incrementar simplemente basado en el addressing y no hacerlo a mano en cada caso.

>> 2015-05-10 Domingo

Hace unos días finalmente empecé a correr nestest. La primera serie de corridas y posteriormente comparando el log de nestest con el de ModNES me permitió
confirmar que el Cpu6502 estaba corriendo casi perfectamente.
Descubrí algunos bugs seteando el flag de carry, pero salvo eso, todo lo demás parecía estar correctamente implementado.
Luego emulando a la perfección el formato de log de nestest con conteo de ciclos de PPU y con direcciones de addressing, encontré un bug que todavía tengo
que esclarecer.
Después de correr 3300 instrucciones a la perfección, falla `STA ($33),Y` y no escribe en memoria el valor que debería, seguramente el indirect indexed Y tiene
un bug que ya arreglaré.
También debería agregar los addressing modes de los NOP ilegales, más que nada para saber cuántos bytes ocupan esas instrucciones y poder incrementar el pc
en consecuencia, ignorando los efectos colaterales que el estéril addressing de los NOP pudiera causar.
Implementar los NOP ilegales me permite llegar un poco más allá dentro del log de nestest para verificar un poco más la correctitud del Cpu6502

>> 2015-04-23

Hoy corriendo ModNES con Mario Bros. me di cuenta que no había implementado ASL,LSR,ROR,ROL con addressing "Accumulator".
Habría que agregarlos a los tests que corresponda.

Hace varios meses que tenía a ModNES abandonado pensando que Mario Bros. había querido ejecutar una opcode ilegal, lo que suponía uno de dos posibles problemas;
1) Que efectivamente Mario Bros. usara opcodes ilegales, con lo cual probablemente otros juegos Mapper 0 también lo hicieran, y tendría que implementar
opcodes ilegales antes de poder correr las primeras pruebas.
2) Que la ejecución se hubiera desfasado de alguna manera y se estuvieran interpretando operandos como opcodes y viceversa, lo cual implicaba volver a testear
minuciosamente Cpu6502 para encontrar el error.

Por suerte $0A no era una opcode ilegal sino que era ASL A que no estaba implementada.

Diantres! Seguí la ejecución y ahora sí, quiso ejecutar la instrucción $04 que es ilegal. :(
Sin embargo llega a esa instrucción después de un JMP ($0014), así que puede ser que la indirección sea incorrecta.